Design
How the app was implemented

iOS applications, written with Objective-c and in the IDE Xcode, are object-oriented mobile applications based on the MVC (model view controller) model.  These factors all seriously influenced the design of our app.  

	Firstly, Xcode allows for the easy compilation of multiple files.  Such allowed us to not have to hesitate when another subclass or view controller was required for what we wanted to do.  

	MVC influenced design in that we tried to respect this optimal hierarchy.  There is one app delegate, which provides data to a root view controller.  This view controller then sends data to the desired root controller.  In the sub controllers, models are created in code, which are then sent, through the view controller, to the view itself.   Because of this hierarchy, whenever views had to perform actual work (rather than just exist for appearance), we found it easier to programmatically populate our interactive objects (especially in a game context).  Though the code to produce one UIView object might at first seem long and random, this type of code is very customizable and easily copied and pasted.

	Objective-C influenced design in that it comes with countless methods, classes, and subclasses already without having to #import any forgettable or esoteric files. We worked to follow the clear naming style that often makes the language seem like English written without a space bar (e.g. objectDidLoadAtTime:) Often, for example when dealing with array issues, we found that there were already methods that performed the functionality we wanted e.g. ( -removeAllObjects).  Also, memory is, at times, very unusual in objective-c.  With some background in Java, this was an interesting detail to have to work around.  

	Xcode 4.2 introduced Storyboards, which are essentially single files, which contain multiple views (.xib files) with their related transitions between the files.  Although we ended up using more programmatic markup, this file made it easier to plan our application out.  We ended up adding our app delegate with the subview the root controller.  It is this controller’s actions that are displayed when the app runs.  Since the root view is very static, it was most simple to just use interface builder and automatic markup to arrange the objects and link them to their related functions via key terms like (IBAction) and (IBOutlet).  Each button calls a method that overlays the next view on the screen and these views have a return function which removes this overlay.  We also, just for fun, added the dynamic water to the bottom of the root view (this was written for the game view originally and will be explained there). Besides loading in the images and displaying them, that is the entirety of the root view.

	If one taps the button for cs50.net, they are taken to the cs50 view overlay which contains a nav bar with a back button (that is linked to a return function) and a webview that loads cs50.net and zooms out to fit the entire site.  This is essentially the entirety of this view, and writing it simply involved learning the different keywords for each object.

	Next there is the game view: the meat of the app. We begin by creating instance variables / getters & setters (via objective-c 2.0 @property/@synthesize).  The first few are simply the images and related views for all our objects in the game.  The rest,  are more interesting objects we will explain as they become relevant.  There are also many methods to be explained later.  The UIImages define what the objects look like, and the UIImageViews allow us to actually instantiate and manipulate the objects.  When viewDidLoad gets called (when the view loads, of course), we set all our critical counters to zero ( to avoid garbage values, etc) and then creates our image(views) and interface (using manual markup).  We also create an array which will hold our spawned platforms.

	Our next piece of interesting syntax is an alert, which is created at the start after this initialization and contains instructions.  To receive alert view data (and accelerometer later) we had to set the game view controller as a delegate for each at the top of the file.  When the app receives this data, it calls our alertView function (the declaration supplied by apple) which has two possible buttons.  Button 0 is usually a start/continue game button, but if the game’s won it becomes a main menu button and the second button is not shown.  Here, however, it starts the game (later there will be a second button with this main menu functionality).  This alert function also starts our timers and accelerometer, because it will later be set so that these are paused whenever the game is paused.

	We have two timers: one to spawn platforms, and one to move them.  platformTimer runs every second and launches the onTimer method (which spawns platforms).  movementTimer runs every 0.01 seconds and moves the platforms via the onUpdatePlatforms method. Before we jump into this, note also that there are methods to start and stop the accelerometer.  We made this so that when paused the game can not receive input (or when the game is won, etc).  It is also, we think, much better style (a theme we tried to repeat).

	We have our menuAlert method which gets called when the player hits the pause button in the lower-left corner of the display.  This buttons (as promised) stops all timers and the accelerometer and then hides the current platforms stored in the platform array.  It then populates the pause alert.

	onTimer works, at first, similar to viewDidLoad.  It populates a platform image and view in the same way.  However, the platforms x coordinate is set via a random() which sets it as spawning on the left, center, or right.  Then it is created just above the screen and added to the subview (made visible).  Afterwards we gain points for having survived up to this platform (the exponential gain of 10 * the number of platforms survived) and update this on the score label we generated at the start.  We then add this item to our platformArray.  This is where our design became most important, for at first we used a UIAnimation to move the platforms (it was simpler and didn’t require a movement timer).  However, this would not work because the animation simply displayed images while the actual object only existed above and below the screen (where it spawns and despawns).  By the time we had finally figured this out, we had highly simplified our array set up.  We now function under assumption that there will never be more than 6 platforms instantiated.  While this does not work how we wish it would, functionality of the game is existent.  This would be our clear change for version 1.1, but for now we are accepting basic functionality (our original array found empty spots and automatically populated those with the new platforms).  We final update the two indexes of the platform: we use platformIndex to see if it is the next platform and should therefore be removed.  We use arrayIndex to remember where in the array this platform is.

	Most relevant to this is our onUpdatePlatforms.  Every .01 second we move each platform in the array down by 1.5 + (platformCounter * 0.01) up to a value of 4: meaning, the platform speeds will slowly increase but not above what is (admittedly speedy) 4 pixels per second.  Then, as long as the platform’s center is above the bottom of the screen + half the height of the platform ( that would be the center, of course), it will move down normally.  Then, once it is at the bottom, we can move it to under the screen and leave it there for removal.  Since the array does sometimes overflow (we never quite figured that out), we have a manual garbage collection that removes the platforms if more than 50 end up in the array ( a lame corner case correction).

    We also have gravity.  Gravity exists as a timer updating  .1 seconds which, by the way of a counter, creates a velocity of Vo + ½ at^2 for our app.  This gravity gets called whenever the player leaves a surface and then gets reset (so that the acceleration restarts) when the player lands. We have gravity start and stop methods to simplify this.  Gravity was another bright moment in our app’s design.  Related is jump, which gives a value to VelocityY (which is Vo in the gravity equation).  This means that we begin moving up at this VelocityY (the constant jumpY) and continue to do so as gravity incrementally reduces our acceleration until we fall at an increasing rate.  There is also a terminal velocity, which, like most of our constant values, was tuned via guess-and-check methods.

    Our key method is the accelerometer one, which, by way of the accelerometer delegate, gives us accelerometer data at a supplied constant (60 times a second).  We then create a delta.x (what our x should change) by taking the physical acceleration * a constant.  Delta.y is set by the Vf = Vo + 1/2at^2.  We then have many corner cases and conditions.  Whenever the player is on an edge of the screen we want him to not move off of the viewable area (we use a similar conditional for our jump).  We also want gravity to do work upon the player whenever they are in the air, and not do work whenever the player is on a surface.  After these series of conditions are determined, we do some simple arithmetic to our delta.x to make the movement smoother and less of an application of raw coarse data.  We also set a maximum speed.  We then apply this speed to cases where the play can move from side to side and in each, the player will only move in the y direction if it is told to jump/it is in the air and gravity is in effect.

        To round out our accelerometer function, we have our water rotation.  We set a cutoff of 0.01 for acceleration to prevent tiny movements from causing jagged animation.  We then do some further dampening and then base rotation on a trig function supplied in apple’s documentation.  Next, we set left and right cutoff points so the rotation doesn’t become too crazy.  Finally, we set this rotation animation into motion (we can use UIAnimation here, though not with platforms, because we need not compare multiple waters to the player’s location). Finally, we compare the location of the player and the platforms/water:  We use this rect compare method supplied by apple (objective-c is sometimes wonderful) and see if the player is touching any platform in the array.  If true, the player will be told to jump and gravity is started.  Next, we compare to the generic location of the unrotated-water using a supplied rectangle.  If these touch, gameOver will be called.

    gameOver is quite simple.  It sets gameWon to yes, which allows to easily modify many methods to have different behavior.  Then we stop the accelerometer and all timers.  Then finally, after we have set the player to stay in the water at their current x-coordinate, we bring up a gameOver view which displays the player’s final score.  Clicking this button will send the player to the menu and the game can begin anew.  

    Although not perfect, we really like our design, in that although we faced problems, we were consistent and tried to simplify / be as high-level in our code as possible
